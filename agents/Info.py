""" 
Description: 
Author: Xucheng(Timber) Zhang
Date: 2023-12-28
""" 
from datetime import date
import json
import os
import threading
import random

from openai import OpenAI

from config import CONFIG


def description_prompt(**kwargs):
    has_info = ""
    gene_info = ""
    for key in kwargs.keys():
        if key == "description":
            continue
        if kwargs[key]:
            has_info += f"{key}={kwargs[key]},"
        else:
            gene_info += f"{key},"

    prompt = "Generate a description from the following information: "
    prompt += has_info
    prompt += "The following information is missing and need to be generated by you, keep them realistic: "
    prompt += gene_info
    # prompt += "This year is 2023. "
    # prompt += "The income should be in dollars. "
    # prompt += "The birthday should be in the MM-DD-YYYY format. "
    # prompt += "The demographic of this person should represent the US population sample. "
    prompt += "The generated profile should match the following guidance: <"
    prompt += "{Name} is a {age} {race} {gender} living in {street}, {city}, {district}, {state}, {zipcode}. "
    prompt += "The physical status of {Pronoun} is {diesease}. "
    prompt += "{Pronoun} is a {occupation}"
    prompt += "{Pronoun} speaks {language}. Pronoun's education background is {education}. "
    prompt += "{Pronoun}'s date of birth is {birthday}. >"
    prompt += "\n And summarize the key information in your generation, and return in this format: "
    prompt += "{\"description\":\"\" \"name\": \"\", \"gender\": \"\", \"birthday\": \"\", \"race\": \"\", \"city\": \"\", \"disease\" : \"\", "
    prompt += "\"street\": \"\", \"district\": \"\", \"state\": \"\", \"zipcode\": \"\",\"language\": \"\", â€œeducation\":\"\", \"occupation\":\"\"}"

    return prompt


def gpt_description(name, birthday, **kwargs):
    age = int(date.today().year) - int(birthday.split("-")[-1])
    open_ai_client = OpenAI( 
        api_key=CONFIG["openai"]["api_key"],
        organization=CONFIG["openai"]["organization"],
    )
    prompt = description_prompt(name=name, birthday=birthday, age=age, **kwargs)
    completion = open_ai_client.chat.completions.create(
        model="gpt-3.5-turbo", 
        # model="gpt-4",
        messages=[{
            # "role": "system", "content": "You are a census taker who knows everyone, and you write detailed descriptions.",
            "role": "user", "content": prompt
            }]
    )
    return json.loads(completion.choices[0].message.content)


class InfoTree():

    def __init__(self, info, folder) -> None:
        self.user_info = info
        self.folder = folder
        self.tree_file = folder + "/tree.json"
        self.tree = {}

        self.gpt_client = OpenAI(
            api_key=CONFIG["openai"]["api_key"],
            organization=CONFIG["openai"]["organization"],
        )
        
        ######################
        # init : finish init
        # ready :  finish building the tree
        # building : building is undergoing
        # error :  error in building
        self.status = "init"

        if os.path.exists(self.tree_file):
            with open(self.tree_file, "r") as f:
                self.tree = json.load(f)
            self.status = "ready"
        else:
            self._start_building()


    def _start_building(self):
        thread = threading.Thread(target=self._build_tree)
        self.status = "building"
        thread.start()
    

    def _build_tree(self):
        if CONFIG["debug"]:
            self._search_city_state(city=self.user_info["city"], state=self.user_info["state"])
            for idx in self.tree["option"].keys():
                    res = self._search_district(
                        u_city=self.user_info["city"],
                        u_state=self.user_info["state"],
                        city=self.tree["option"][idx]["city"],
                        state=self.tree["option"][idx]["state"],
                        district=self.user_info["district"]
                    )
                    self.tree["option"][idx]["district"] = res
        else:
            try:
                self._search_city_state(city=self.user_info["city"], state=self.user_info["state"])
            except:
                self.status = "error"
            else:
                for idx in self.tree["option"].keys():
                    res = self._search_district(
                        u_city=self.user_info["city"],
                        u_state=self.user_info["state"],
                        city=self.tree["option"][idx]["city"],
                        state=self.tree["option"][idx]["state"],
                        district=self.user_info["district"]
                    )
                    self.tree["option"][idx]["district"] = res
                self.status = "ready"
                with open(self.tree_file, "w") as f:
                    json.dump(self.tree, f)


    def _search_city_state(self, city, state, size=10):
        prompt = f"{city} is a city in {state} state. Based on your understanding, make an evaluation from the dimensions of climate, geographical conditions, and economic development. " 
        prompt += f"Please find me {size} cities with similar conditions from around the world and give the reasons. "
        prompt += "Furthermore, tell me about the races, education and gender statistic in this state. "
        prompt += "The data should based on real information during 2010 to 2020. "
        prompt += "Return your answer in the following JSON format without any other information: "
        prompt += "{\"response\" : [{\"city\" : \"city_1\", \"state\" : \"state/province_1\", \"similarity\" : \"similarity_to_given_city_in_decimal\", "
        prompt += " \"education\": {\"Primary School\":\"population_percentage_in_decimal\", ..., \"Doctor\":\"population_percentage_in_decimal\"}, "
        prompt += " \"races\": {\"race_1\":\"race_1_population_percentage_in_decimal\", ...}, \"gender\": {\"male\":\"gender_percentage_in_decimal\", \"female\":gender_percentage_in_decimal}}, ...], "
        prompt += "\"infomation\" : \"put_other_infomation_you_want_to_tell_here\"}"

        completion = self.gpt_client.chat.completions.create(
            model="gpt-3.5-turbo", 
            # model="gpt-4",
            messages=[{
                "role": "user", "content": prompt
                }]
        )
        # print(completion.choices[0].message.content)
        cities = json.loads(completion.choices[0].message.content)["response"]
        # print(cities)

        _p = 0.0
        self.tree["option"] = {}
        self.tree["prob"] = []
        for idx, city in enumerate(cities):
            self.tree["option"][str(idx)] = {
                    "city" : city["city"],
                    "state" : city["state"],
                    # "education" : city["education"],
                    # "race" : city["races"],
                    "education" : {"option":[k for k in city["education"]], "prob":[float(city["education"][k]) for k in city["education"]]},
                    "race" : {"option":[k for k in city["races"]], "prob":[float(city["races"][k]) for k in city["races"]]},
                    "gender" : {"option":["male", "female"], "prob":[float(city["gender"]["male"]), float(city["gender"]["female"])]},
                    "district" : {},
                }
            self.tree["prob"].append(float(city["similarity"]))
            _p += float(city["similarity"])
        self.tree["prob"] = [x / _p for x in self.tree["prob"]]
        # print(self.tree)
    

    def _search_district(self, u_city, u_state, city, state, district, size=3):
        prompt = f"{district} is a zone in {u_city}, {u_state}. "
        prompt += "Based on your knowledge, to evaluate the convenience of this district, including the population, the infrastructure, and the medical and educational resources. "
        prompt += f"Please find me {size} districts with similar conditions in {city}, {state}. Besides, give me {size} streets in these districts that suitable for living. "
        prompt += "Return your answer in the following JSON format: "
        prompt += "{\"response\" : [{\"district\" : \"district_1\", \"similarity\" : \"similarity_to_given_district_in_decimal\", \"streets\":[\"street_1\", ..., \"street_N\"], ...], "
        prompt += "\"infomation\" : \"put_other_infomation_you_want_to_tell_here\"}"
        

        completion = self.gpt_client.chat.completions.create(
            model="gpt-3.5-turbo", 
            # model="gpt-4",
            messages=[{
                "role": "user", "content": prompt
                }]
        )
        

        if CONFIG["debug"]:
            districts = json.loads(completion.choices[0].message.content)["response"]
            res = {"option":{}, "prob":[]}
            _p = 0.0
            for idx, district in enumerate(districts):
                res["option"][str(idx)] = {
                        "district" : district["district"],
                        "street" : district["streets"],
                    }
                res["prob"].append(float(district["similarity"]))
                _p += float(district["similarity"])
            res["prob"] = [x / _p for x in res["prob"]]

            return res
        else:
            try:
                districts = json.loads(completion.choices[0].message.content)["response"]
            except:
                return completion.choices[0].message.content
            else:
                res = {"option":{}, "prob":[]}
                _p = 0.0
                for idx, district in enumerate(districts):
                    res["option"][str(idx)] = {
                            "district" : district["district"],
                            "street" : district["streets"],
                        }
                    res["prob"].append(float(district["similarity"]))
                    _p += float(district["similarity"])
                res["prob"] = [x / _p for x in res["prob"]]

                return res
    

    def _infer_addtional(self, gender, race, location, education, age_range=5):
        age = int(date.today().year) - int(self.user_info["birthday"].split("-")[-1])
        prompt = f"There is a {race} {gender} living in {location} who has {education} degree. "
        prompt += "Based on the gender and race information, firstly figure out a name. Tell me the exact zip code of where he/she lives, and possible spoken language. "
        prompt += f"Next, the range of the age is {age-age_range}-{age+age_range}, please generate a birthday in this range. "
        prompt += "Finally, based on all of the provided information and your inference, provide a reasonable occupation for him/her and if he/she is retired. "
        prompt += "Return your answer in the following JSON format: "
        prompt += "{\"response\" : {\"name\" : \"firstname familyname\", \"birthday\" : \"MM-DD-YYYYY\", "
        prompt += "\"language\" : \"language\", \"zipcode\" : \"zipcode\", \"occupation\":\"occupation\", \"retirement\":\"retired_or_working\"}, "
        prompt += "\"infomation\" : \"put_other_infomation_you_want_to_tell_here\"}"
        

        completion = self.gpt_client.chat.completions.create(
            model="gpt-3.5-turbo", 
            # model="gpt-4",
            messages=[{
                "role": "user", "content": prompt
                }]
        )
        return json.loads(completion.choices[0].message.content)["response"]


    def generate_info_dict(self):
        res = {key:None for key in self.user_info}
        city_choice = random.choices([str(i) for i in range(len(self.tree["prob"]))], weights=self.tree["prob"])[0]
        city = self.tree["option"][city_choice]
        res["city"] = city["city"]
        res["state"] = city["state"]

        res["gender"] = random.choices(["male", "female"], weights=city["gender"]["prob"])[0]
        res["race"] = random.choices(city["race"]["option"][:-1], weights=city["race"]["prob"][:-1])[0]
        res["education"] = random.choices(city["education"]["option"], weights=city["education"]["prob"])[0]

        district_choice = random.choices([str(i) for i in range(len(city["district"]["prob"]))], weights=city["district"]["prob"])[0]
        district = city["district"]["option"][district_choice]
        res["district"] = district["district"]
        res["street"] = random.choices(district["street"])[0]

        add_info = self._infer_addtional(
            gender=res["gender"],
            race=res["race"],
            education=res["education"],
            location=f"{res['street']}, {res['district']}, {res['city']}, {res['state']}"
        )
        res["name"] = add_info["name"]
        res["birthday"] = add_info["birthday"]
        res["zipcode"] = add_info["zipcode"]
        res["language"] = add_info["language"]
        res["occupation"] = add_info["occupation"]
        res["retirement"] = add_info["retirement"]
        
        return res


    def get_status(self):
        return self.status
    

