""" 
Description: 
Author: Xucheng(Timber) Zhang
Date: 2023-12-28
""" 
from datetime import date
import json
import threading

from openai import OpenAI

from config import CONFIG


def description_prompt(**kwargs):
    has_info = ""
    gene_info = ""
    for key in kwargs.keys():
        if key == "description":
            continue
        if kwargs[key]:
            has_info += f"{key}={kwargs[key]},"
        else:
            gene_info += f"{key},"

    prompt = "Generate a description from the following information: "
    prompt += has_info
    prompt += "The following information is missing and need to be generated by you, keep them realistic: "
    prompt += gene_info
    # prompt += "This year is 2023. "
    # prompt += "The income should be in dollars. "
    # prompt += "The birthday should be in the MM-DD-YYYY format. "
    # prompt += "The demographic of this person should represent the US population sample. "
    prompt += "The generated profile should match the following guidance: <"
    prompt += "{Name} is a {age} {race} {gender} living in {street}, {city}, {state}, {zipcode}. "
    prompt += "The physical status of {Pronoun} is {diesease}. "
    prompt += "{Pronoun} is a {occupation}"
    prompt += "{Pronoun} speaks {language}. Pronoun's education background is {education}. "
    prompt += "{Pronoun}'s date of birth is {birthday}. >"
    prompt += "\n And summarize the key information in your generation, and return in this format: "
    prompt += "{\"description\":\"\" \"name\": \"\", \"gender\": \"\", \"birthday\": \"\", \"race\": \"\", \"city\": \"\", \"disease\" : \"\", "
    prompt += "\"street\": \"\", \"district\": \"\", \"state\": \"\", \"zipcode\": \"\",\"language\": \"\", â€œeducation\":\"\", \"occupation\":\"\"}"

    return prompt


def gpt_description(name, birthday, **kwargs):
    age = int(date.today().year) - int(birthday.split("-")[-1])
    open_ai_client = OpenAI(
        api_key=CONFIG["openai"]["api_key"],
        organization=CONFIG["openai"]["organization"],
    )
    prompt = description_prompt(name=name, birthday=birthday, age=age, **kwargs)
    completion = open_ai_client.chat.completions.create(
        model="gpt-3.5-turbo", 
        # model="gpt-4",
        messages=[{
            # "role": "system", "content": "You are a census taker who knows everyone, and you write detailed descriptions.",
            "role": "user", "content": prompt
            }]
    )
    return json.loads(completion.choices[0].message.content)


class InfoTree():

    def __init__(self, info) -> None:
        # self.info = {
        #     "name" : None,
        #     "gender" : None,
        #     "race" : None,
        #     "birthday" : None,
        #     "city" : None,
        #     "disease" : None,
        #     "street" : None,
        #     "district" : None,
        #     "state" : None,
        #     "zipcode" : None,
        #     "education" : None,
        #     "language" : None,
        #     "occupation" : None
        # }
        self.info = info
        self.tree = {}

        self.gpt_client = OpenAI(
            api_key=CONFIG["openai"]["api_key"],
            organization=CONFIG["openai"]["organization"],
        )
        
        ######################
        # init : finish init
        # finish :  finish building the tree
        # building : building is undergoing
        # error :  error in building
        self._status = "init"

        self._start_building()


    def _start_building(self):
        thread = threading.Thread(target=self._build_tree)
        self._status = "building"
        thread.start()
    

    def _build_tree(self):
        try:
            self._search_city_state(city=self.info["city"], state=self.info["state"])
        except:
            self._status = "error"
        else:
            for idx in self.tree["option"].keys():
                res = self._search_district(
                    u_city=self.info["city"],
                    u_state=self.info["state"],
                    city=self.tree["option"][idx]["city"],
                    state=self.tree["option"][idx]["state"],
                    district=self.info["district"]
                )
                self.tree["option"][idx]["district"] = res
            self._status = "finish"
        with open("tree_test.json", "w") as f:
            json.dump(self.tree, f)



    def _search_city_state(self, city, state, size=10):
        prompt = f"{city} is a city in {state} state. Based on your understanding, make an evaluation from the dimensions of climate, geographical conditions, and economic development." 
        prompt += f"Please find me {size} cities with similar conditions from around the world and give the reasons."
        prompt += "Return your answer in the following JSON format: "
        prompt += "[{\"city\" : \"city_1\", \"state\" : \"state/province_1\", \"similarity\" : \"similarity_to_given_city_in_decimal\", \"reason\" : \"reason_for_chosen\"}, "
        prompt += "... , {\"city\" : \"city_N\", \"state\" : \"state/province_N\", \"similarity\" : \"similarity_to_given_city_in_decimal\",  \"reason\" : \"reason_for_chosen\"}]"

        completion = self.gpt_client.chat.completions.create(
            model="gpt-3.5-turbo", 
            # model="gpt-4",
            messages=[{
                "role": "user", "content": prompt
                }]
        )
        # print(completion.choices[0].message.content)
        cities = json.loads(completion.choices[0].message.content)

        _p = 0.0
        self.tree["option"] = {}
        self.tree["prob"] = []
        for idx, city in enumerate(cities):
            self.tree["option"][idx] = {
                    "city" : city["city"],
                    "state" : city["state"],
                    "district" : {},
                    "r" : city["reason"],
                }
            self.tree["prob"].append(float(city["similarity"]))
            _p += float(city["similarity"])
        self.tree["prob"] = [x / _p for x in self.tree["prob"]]
    

    def _search_district(self, u_city, u_state, city, state, district, size=3):
        prompt = f"{district} is a zone in {u_city}, {u_state}. "
        prompt += "Based on your knowledge, to evaluate the convenience of this district, including the population, the infrastructure, and the medical and educational resources. "
        prompt += f"Please find me {size} districts with similar conditions in {city}, {state}. Besides, give me {size} streets in these districts that suitable for living. "
        # prompt += "Furthermore, tell me about the races, education and gender statistic in this district. The data should based on real information during 2010 to 2020"
        prompt += "Return your answer in the following JSON format: "
        prompt += "[{\"district\" : \"district_1\", \"similarity\" : \"similarity_to_given_district_in_decimal\", \"reason\" : \"reason_for_chosen\", \"streets\":[\"street_1\", ..., \"street_N\"], ...]"
        # prompt += " \"education\": {\"Primary School\":\"population_percentage_in_decimal\", ..., \"Doctor\":\"population_percentage_in_decimal\"}, "
        # prompt += " \"races\": {\"race_1\":\"race_1_population_percentage_in_decimal\", ...}, \"gender\": {\"male\":gender_percentage_in_decimal, \"female\":gender_percentage_in_decimal}}, ...]"
        

        completion = self.gpt_client.chat.completions.create(
            model="gpt-3.5-turbo", 
            # model="gpt-4",
            messages=[{
                "role": "user", "content": prompt
                }]
        )
        # print(completion.choices[0].message.content)
        try:
            districts = json.loads(completion.choices[0].message.content)
        except:
            return completion.choices[0].message.content
        else:
            res = {"option":{}, "prob":[]}
            _p = 0.0
            for idx, district in enumerate(districts):
                res["option"][idx] = {
                        "district" : district["district"],
                        "street" : district["streets"],
                        # "race" : {},
                        # "education" : {},
                        # "gender" : {"option":{0:"male", 1:"female"}, "prob":[district["gender"]["male"], district["gender"]["female"]]},
                        "r" : district["reason"],
                    }
                res["prob"].append(float(district["similarity"]))
                _p += float(district["similarity"])
            res["prob"] = [x / _p for x in res["prob"]]

            return res

    def get_status(self):
        return self._status
    

